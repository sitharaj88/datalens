import * as fs from 'fs';
import type { IDatabaseAdapter } from '../database/interfaces/IAdapter';
import type { DatabaseType } from '../../shared/types/database';

export interface BackupOptions {
  tables?: string[];
  schemaOnly?: boolean;
  dataOnly?: boolean;
}

export interface BackupResult {
  outputPath: string;
  tablesBackedUp: number;
  duration: number;
}

export interface RestoreResult {
  tablesRestored: number;
  statementsExecuted: number;
  duration: number;
  errors: string[];
}

export class BackupRestoreService {
  async backup(
    adapter: IDatabaseAdapter,
    dbType: DatabaseType,
    outputPath: string,
    options?: BackupOptions
  ): Promise<BackupResult> {
    const startTime = Date.now();
    const allTables = await adapter.getTables();
    const tables = options?.tables
      ? allTables.filter(t => options.tables!.includes(t.name))
      : allTables;

    // Special case for SQLite: copy the file
    if (dbType === 'sqlite') {
      return this.backupSQLite(adapter, outputPath, tables.length, startTime);
    }

    const lines: string[] = [];
    lines.push(`-- Database backup generated by Database Viewer Pro`);
    lines.push(`-- Date: ${new Date().toISOString()}`);
    lines.push(`-- Database type: ${dbType}`);
    lines.push('');

    for (const table of tables) {
      // Schema
      if (!options?.dataOnly) {
        const columns = await adapter.getColumns(table.name);
        lines.push(`-- Table: ${table.name}`);
        const colDefs = columns.map(col => {
          let def = `  "${col.name}" ${col.type}`;
          if (col.primaryKey) def += ' PRIMARY KEY';
          if (col.autoIncrement) def += ' AUTOINCREMENT';
          if (!col.nullable && !col.primaryKey) def += ' NOT NULL';
          if (col.defaultValue !== undefined) def += ` DEFAULT ${col.defaultValue}`;
          return def;
        });
        lines.push(`CREATE TABLE IF NOT EXISTS "${table.name}" (`);
        lines.push(colDefs.join(',\n'));
        lines.push(');');
        lines.push('');
      }

      // Data
      if (!options?.schemaOnly) {
        const result = await adapter.getTableData(table.name);
        if (result.rows.length > 0) {
          for (const row of result.rows) {
            const cols = result.columns.map(c => `"${c.name}"`).join(', ');
            const vals = result.columns.map(c => {
              const v = row[c.name];
              if (v === null || v === undefined) return 'NULL';
              if (typeof v === 'number') return String(v);
              if (typeof v === 'boolean') return v ? '1' : '0';
              return `'${String(v).replace(/'/g, "''")}'`;
            }).join(', ');
            lines.push(`INSERT INTO "${table.name}" (${cols}) VALUES (${vals});`);
          }
          lines.push('');
        }
      }
    }

    fs.writeFileSync(outputPath, lines.join('\n'), 'utf-8');

    return {
      outputPath,
      tablesBackedUp: tables.length,
      duration: Date.now() - startTime,
    };
  }

  async restore(
    adapter: IDatabaseAdapter,
    _dbType: DatabaseType,
    inputPath: string,
  ): Promise<RestoreResult> {
    const startTime = Date.now();
    const content = fs.readFileSync(inputPath, 'utf-8');
    const errors: string[] = [];

    // Split by semicolons, filter comments and empty lines
    const statements = content
      .split(';')
      .map(s => s.trim())
      .filter(s => s.length > 0 && !s.startsWith('--'));

    let statementsExecuted = 0;
    const tablesRestored = new Set<string>();

    for (const stmt of statements) {
      try {
        await adapter.executeQuery(stmt + ';');
        statementsExecuted++;

        // Track table names from CREATE TABLE or INSERT INTO statements
        const tableMatch = stmt.match(/(?:CREATE TABLE|INSERT INTO)\s+(?:IF NOT EXISTS\s+)?"?(\w+)"?/i);
        if (tableMatch) {
          tablesRestored.add(tableMatch[1]);
        }
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        if (errors.length < 20) {
          errors.push(`Statement failed: ${stmt.substring(0, 80)}... Error: ${msg}`);
        }
      }
    }

    return {
      tablesRestored: tablesRestored.size,
      statementsExecuted,
      duration: Date.now() - startTime,
      errors,
    };
  }

  private async backupSQLite(
    adapter: IDatabaseAdapter,
    outputPath: string,
    tableCount: number,
    startTime: number
  ): Promise<BackupResult> {
    // For SQLite, generate a SQL dump since we may not have direct file access
    const tables = await adapter.getTables();
    const lines: string[] = [];
    lines.push(`-- SQLite backup generated by Database Viewer Pro`);
    lines.push(`-- Date: ${new Date().toISOString()}`);
    lines.push('');

    for (const table of tables) {
      const schemaResult = await adapter.executeQuery(
        `SELECT sql FROM sqlite_master WHERE type='table' AND name='${table.name.replace(/'/g, "''")}'`
      );
      if (schemaResult.rows.length > 0 && schemaResult.rows[0].sql) {
        lines.push(String(schemaResult.rows[0].sql) + ';');
        lines.push('');
      }

      const result = await adapter.getTableData(table.name);
      for (const row of result.rows) {
        const cols = result.columns.map(c => `"${c.name}"`).join(', ');
        const vals = result.columns.map(c => {
          const v = row[c.name];
          if (v === null || v === undefined) return 'NULL';
          if (typeof v === 'number') return String(v);
          if (typeof v === 'boolean') return v ? '1' : '0';
          return `'${String(v).replace(/'/g, "''")}'`;
        }).join(', ');
        lines.push(`INSERT INTO "${table.name}" (${cols}) VALUES (${vals});`);
      }
      lines.push('');
    }

    fs.writeFileSync(outputPath, lines.join('\n'), 'utf-8');

    return {
      outputPath,
      tablesBackedUp: tableCount,
      duration: Date.now() - startTime,
    };
  }
}
